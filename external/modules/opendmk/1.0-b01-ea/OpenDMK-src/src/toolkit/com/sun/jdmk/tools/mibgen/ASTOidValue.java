/*
 * @(#)file      ASTOidValue.java
 * @(#)author    Sun Microsystems, Inc.
 * @(#)version   4.15
 * @(#)date      07/04/04
 *
 * 
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.
 * 
 * Copyright (c) 2007 Sun Microsystems, Inc. All Rights Reserved.
 * 
 * The contents of this file are subject to the terms of either the GNU General
 * Public License Version 2 only ("GPL") or the Common Development and
 * Distribution License("CDDL")(collectively, the "License"). You may not use
 * this file except in compliance with the License. You can obtain a copy of the
 * License at http://opendmk.dev.java.net/legal_notices/licenses.txt or in the 
 * LEGAL_NOTICES folder that accompanied this code. See the License for the 
 * specific language governing permissions and limitations under the License.
 * 
 * When distributing the software, include this License Header Notice in each
 * file and include the License file found at
 *     http://opendmk.dev.java.net/legal_notices/licenses.txt
 * or in the LEGAL_NOTICES folder that accompanied this code.
 * Sun designates this particular file as subject to the "Classpath" exception
 * as provided by Sun in the GPL Version 2 section of the License file that
 * accompanied this code.
 * 
 * If applicable, add the following below the License Header, with the fields
 * enclosed by brackets [] replaced by your own identifying information:
 * 
 *       "Portions Copyrighted [year] [name of copyright owner]"
 * 
 * Contributor(s):
 * 
 * If you wish your version of this file to be governed by only the CDDL or
 * only the GPL Version 2, indicate your decision by adding
 * 
 *       "[Contributor] elects to include this software in this distribution
 *        under the [CDDL or GPL Version 2] license."
 * 
 * If you don't indicate a single choice of license, a recipient has the option
 * to distribute your version of this file under either the CDDL or the GPL
 * Version 2, or to extend the choice of license to its licensees as provided
 * above. However, if you add GPL Version 2 code and therefore, elected the
 * GPL Version 2 license, then the option applies only if the new code is made
 * subject to such option by the copyright holder.
 * 
 *
 */


/* Generated By:JJTree: Do not edit this line. ASTOidValue.java */

package com.sun.jdmk.tools.mibgen;
import java.util.*;

public class ASTOidValue extends SimpleNode {
    ASTOidValue(int id) {
        super(id);
    }

    ASTOidValue(Parser p, int id) {
        super(p, id);
    }

    public static Node jjtCreate(int id) {
        return new ASTOidValue(id);
    }

    public static Node jjtCreate(Parser p, int id) {
        return new ASTOidValue(p, id);
    }
  
    public void resolve(IdentifierHandler handler) {
    
        int nb= children.length;
        if (nb == 0)
            // Cool case ... I like that
            return;
        for(int index= 0; index < nb; index++) {
            SimpleNode aNode= (SimpleNode) children[index];
            if (aNode.id == ParserTreeConstants.JJTOBJECTSUBID)
                ((ASTObjectSubID)aNode).resolve(handler);
        }
    }
  
    public void resolve(IdentifierHandler handler, String key) {
        // just register ourselves ...
        //
        handler.addResolution(key, this);
        resolve(handler);
    }
  
    public StringBuffer computeValue(Vector referenceList) throws SemanticException{
        StringBuffer result= new StringBuffer();
    
        if ((children == null) || (children.length == 0))
            return result;
    
        boolean first= true;
        for(int i=0; i <children.length; i++) {
            if (!first)
                result.append(".");
            else
                first= false;
            ASTObjectSubID subId= (ASTObjectSubID) children[i];
            result.append((Object) subId.computeValue(referenceList));
	    /* (Object) cast is because J2SE 1.4 added a method
	       StringBuffer.add(StringBuffer), which otherwise
	       we end up calling here; therefore if you compile
	       with 1.4 but run on an earlier version it fails.  */
        }
        dotNotation= result;
        return result;
    }
    
    /** 
     * Retrieve the default value for the BITS type:
     * This default value is a singleton (ex: { { blue } } )
     */
    public String getDefValBITS() {
    
        if ((children == null) || (children.length != 1))
            return null;
    
        ASTObjectSubID subId= (ASTObjectSubID) children[0];
        return subId.getDefValBITS();
    }
  
    public StringBuffer getDotNotation() {
        
        // DEFVAL for OBJECT IDENTIFIER values:
        // Compute the default value if needed
        //
        if (dotNotation == null) {
            try {
                dotNotation = computeValue(new Vector());
            } catch(SemanticException e) {
                dotNotation = null;
            }
        }
        return dotNotation;
    }
  
    public String getDefValInitializer(String strMbeanSyntax, ASTNamedType syntax, String varName) {
                                
        String result = new String();
        
        int intSnmpSyntax = SyntaxMapper.getIntSnmpSyntax(syntax.getSnmpSyntax());
        
        switch(intSnmpSyntax) {
        case SyntaxMapper.OBJECT_ID:
            StringBuffer dotString = getDotNotation();
            if (dotString != null) {
                result = new String(" = new " + strMbeanSyntax.trim() + "(\"" + dotString + "\")");
            }
            break;
        case SyntaxMapper.BYTE:
            if (syntax.isEnumeratedBITSType()) {
                String strDefVal = getDefValBITS();
                Hashtable enumeration =  syntax.getEnumeratedBITSDef().getEnum();
                String defValBITS = calculateDefValBITS(enumeration, strDefVal);
                if (defValBITS != null)
                    result = " = {" + defValBITS + "}";
                else
                    Trace.warning(MessageHandler.getMessage("compile.w.defval", strDefVal, varName));
            }
            break;
        default:
            break;
        }        
        
        return result;
    }
    
    String calculateDefValBITS(Hashtable enumeration, String strDefVal) {
        
        StringBuffer result = new StringBuffer();
        
        // Get the max bit number (among all the enumeration values).
        //
        int maxIntDefVal = 0;
        for (Enumeration e = enumeration.elements(); e.hasMoreElements(); ) {
            maxIntDefVal = Math.max(maxIntDefVal, (new Integer((String)e.nextElement())).intValue());
        }
        
        // Get the bit number to be set.
        // There is only one bit to be set.
        //
        int intDefVal = 0;
        try {
            intDefVal = new Integer((String)enumeration.get(strDefVal)).intValue();
        } catch(NumberFormatException e) { 
            return null;
        }
        
        // Initialize the byte array.
        // All the byte values are set to null except the one containing to the default value bit number.
        // (this bit number is set in the corresponding byte).
        //
        int nbBytes = (int)(maxIntDefVal/8) + 1;
        byte b[] = new byte[nbBytes];
        for (int i = 0; i < nbBytes; i++) {
            b[i] = 0x00;
        }
        b[((int)(intDefVal/8))] = byteTab[7-(int)(intDefVal%8)];
        
        // Initialize the default value
        //
        for (int i = 0; i < nbBytes; i++) {
            result.append(" new Byte(\"");
            result.append(b[i]);
            result.append("\")");
            if (i < nbBytes-1)
                result.append(",");
        }
        return new String(result); 
    }
    
    static byte byteTab [] = {
        ((byte)0x01),
        ((byte)0x02),
        ((byte)0x04),
        ((byte)0x08),
        ((byte)0x10),
        ((byte)0x20),
        ((byte)0x40),
        ((byte)0x80) };
    
    protected StringBuffer dotNotation= null;
}
  
  
