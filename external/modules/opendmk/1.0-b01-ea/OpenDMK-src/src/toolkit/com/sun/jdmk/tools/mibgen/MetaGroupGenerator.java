/* 
 * @(#)file      MetaGroupGenerator.java 
 * @(#)author    Sun Microsystems, Inc. 
 * @(#)version   1.20 
 * @(#)date      07/04/04 
 * 
 * 
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.
 * 
 * Copyright (c) 2007 Sun Microsystems, Inc. All Rights Reserved.
 * 
 * The contents of this file are subject to the terms of either the GNU General
 * Public License Version 2 only ("GPL") or the Common Development and
 * Distribution License("CDDL")(collectively, the "License"). You may not use
 * this file except in compliance with the License. You can obtain a copy of the
 * License at http://opendmk.dev.java.net/legal_notices/licenses.txt or in the 
 * LEGAL_NOTICES folder that accompanied this code. See the License for the 
 * specific language governing permissions and limitations under the License.
 * 
 * When distributing the software, include this License Header Notice in each
 * file and include the License file found at
 *     http://opendmk.dev.java.net/legal_notices/licenses.txt
 * or in the LEGAL_NOTICES folder that accompanied this code.
 * Sun designates this particular file as subject to the "Classpath" exception
 * as provided by Sun in the GPL Version 2 section of the License file that
 * accompanied this code.
 * 
 * If applicable, add the following below the License Header, with the fields
 * enclosed by brackets [] replaced by your own identifying information:
 * 
 *       "Portions Copyrighted [year] [name of copyright owner]"
 * 
 * Contributor(s):
 * 
 * If you wish your version of this file to be governed by only the CDDL or
 * only the GPL Version 2, indicate your decision by adding
 * 
 *       "[Contributor] elects to include this software in this distribution
 *        under the [CDDL or GPL Version 2] license."
 * 
 * If you don't indicate a single choice of license, a recipient has the option
 * to distribute your version of this file under either the CDDL or the GPL
 * Version 2, or to extend the choice of license to its licensees as provided
 * above. However, if you add GPL Version 2 code and therefore, elected the
 * GPL Version 2 license, then the option applies only if the new code is made
 * subject to such option by the copyright holder.
 * 
 */ 
package com.sun.jdmk.tools.mibgen;

import java.lang.*;
import java.util.*;
import java.io.*;

/**
 * This class implements a generator for groups that can have nested
 * subgroups. It specializes the MetaBeanGenerator in order to
 * generate additional supports for nested groups.
 *
 * Groups that will never have any nested subgroups can still be
 * generated via the original MetaBeanGenerator. However, in the 
 * current implementation, all the groups are now generated using
 * the new MetaGroupGenerator, even if the MIB doesn't define any
 * subgroups. 
 *
 * Groups generated using the MetaGroupGenerator keep the capability
 * to have dynamically registered subgroups at run time, even if
 * this is not defined in the MIB. The MIB and its implementation can
 * thus have separate lives.
 */

class MetaGroupGenerator extends MetaBeanGenerator {
    public MetaGroupGenerator(ResourceManager mgr, MibNode aGroup, 
			      Context ctxt)
	throws IOException {
	super(mgr,aGroup,ctxt);
    }

    // Initializes the string buffers
    //
    protected void initBuffers() {
	super.initBuffers();
	tablecount = 0;
	getTable_impl    =  new StringBuffer();
	getTable_body    =  new StringBuffer();
	regTable_impl    =  new StringBuffer();
	isTable_impl     =  new StringBuffer();
	factory_impl     =  new StringBuffer();
    }

    // Used to set the parent class to SnmpMibGroup (rather than to
    // SnmpMibNode)
    protected String getParentClass() {
	return Def.SNMP_GROUP;
    }

    // Used to import com.sun.management.snmp.agent.SnmpMibGroup (rather than
    // com.sun.management.snmp.agent.SnmpMibNode)
    protected String getParentClassPkg() {
	return Def.PKG_SNMP_MIB_GROUP;
    }

    // Used to change the initialization of the varList[] array.
    // For groups which have nested groups, this initialization
    // must be done through the registerVar() method.
    //
    protected void handleInit(String id, String var, int acc) 
	throws IOException {
        if ((acc == ParserConstants.RO)||
            (acc == ParserConstants.RC)||
            (acc == ParserConstants.RW)) {
            init_impl.append(Def.TAB3 + Def.METH_REGISTER_VAR + "(" + id 
			     + ")" + Def.SEMICOLON);
            counter ++;
        }
    }

    /**
     * Writing end of stuff for constructor
     *
     * Changed to catch the IllegalAccessException generated by the
     * registerVar() method.
     */
    protected void closeConstructor() throws IOException {
	// The try { ... } catch () {...} statement must be omitted
	// when no registerVar() method is called.

	// Bug Fix: 4306630 - write-only objects are not initialized,
	//          the constructor body may be empty.
	if (counter > 0) {
	    constructor.append(Def.TAB2 + "try " + Def.N_LBRACE);
	}

	constructor.append(init_impl.toString());

	// Bug Fix: 4306630 - write-only objects are not initialized,
	//          the constructor body may be empty.
	if (counter > 0) {
	    constructor.append(Def.TAB2 + Def.N_RBRACE + " catch (" + 
			       Def.EXCP_ILLEGAL + " e)" + Def.LBRACE);
	    constructor.append(Def.TAB3 + "throw new " + Def.EXCP_RT +
			       "(e.getMessage())" + Def.SEMICOLON);
	    constructor.append(Def.TAB2 + Def.RBRACE);
	}
        constructor.append( Def.TAB + Def.RBRACE + "\n");	
    }

    protected void buildIsTableHeader() throws IOException {
        isTable_impl.append(Def.TAB + "/**\n"+ Def.TAB + " * " +
			       MessageHandler.getMessage("generate.meta.comment.istable","arc") + "\n" +
			       Def.TAB + " */\n" + Def.TAB + Def.PUBLIC + 
			       "boolean" + " " +
			       Def.METH_IS_TABLE + "(long arc)" + Def.LBRACE);
    
        isTable_impl.append("\n" + Def.TAB2 + "switch((int)arc)" + 
			       Def.LBRACE);
    }
  
    protected void handleIsTable(MibNode aNode,String name,String id) 
	throws IOException {
        isTable_impl.append(Def.TAB3 + "case " + id + ":\n");
        isTable_impl.append(Def.TAB4 + "return true" + Def.SEMICOLON);
    }

    protected void closeIsTable() throws IOException {
        isTable_impl.append(Def.TAB3 + "default:\n");
	isTable_impl.append(Def.TAB4 + "break" + Def.SEMICOLON);
        isTable_impl.append(Def.TAB2 + Def.RBRACE);
	isTable_impl.append(Def.TAB2 + "return false"+Def.SEMICOLON);
        isTable_impl.append(Def.TAB +  Def.RBRACE + "\n");
    }

    protected void buildGetTableHeader() throws IOException {
        getTable_impl.append(Def.TAB + "/**\n"+ Def.TAB + " * " +
			     MessageHandler.getMessage("generate.meta.comment.gettable","arc") + "\n" +
			     Def.TAB + " */\n" + Def.TAB + Def.PUBLIC + 
			     Def.SNMP_TABLE + " " +
			     Def.METH_GET_TABLE + "(long arc)" + Def.LBRACE);
    
    }
  
    protected void handleGetTable(MibNode aNode,String name,String id) 
	throws IOException {
        getTable_body.append(Def.TAB3 + "case " + id + ":\n");
        getTable_body.append(Def.TAB4 + "return table" + name + 
			     Def.SEMICOLON);
    }

    protected void closeGetTable() throws IOException {
	if (tablecount > 0) {
	    // getTable_impl.append("\n" + Def.TAB2 + "try" + 
	    //                      Def.LBRACE);
	    getTable_impl.append("\n" + Def.TAB2 + "switch((int)arc)" + 
				 Def.LBRACE);
	    getTable_impl.append((Object) getTable_body);
	    /* (Object) cast is because J2SE 1.4 added a method
	       StringBuffer.add(StringBuffer), which otherwise
	       we end up calling here; therefore if you compile
	       with 1.4 but run on an earlier version it fails.  */
	    getTable_impl.append(Def.TAB2 + "default:\n");
	    getTable_impl.append(Def.TAB3 + "break" + Def.SEMICOLON);
	    getTable_impl.append(Def.TAB2 + Def.RBRACE);
	    // getTable_impl.append(Def.TAB2 + Def.N_RBRACE + " catch(" + 
	    //	                    Def.EXCP_SNMP + " e) " + Def.LBRACE );
	    // getTable_impl.append(Def.TAB3 + "return null" + Def.SEMICOLON);
	    // getTable_impl.append(Def.TAB2 + Def.RBRACE);
	}
	getTable_impl.append(Def.TAB2 + "return null"+Def.SEMICOLON);
	getTable_impl.append(Def.TAB +  Def.RBRACE + "\n");
    }

    protected void buildRegisterTableHeader() throws IOException {
        regTable_impl.append(Def.TAB + "/**\n"+ Def.TAB + " * " +
			     MessageHandler.getMessage("generate.meta.comment.regtables") + "\n" +
			     Def.TAB + " */\n" + Def.TAB + Def.PUBLIC + 
			     Def.VOID +
			     Def.METH_T_REGTABLES + "(" + Def.SNMP_MIB + 
			     " mib, " + Def.MBEANSERVER + " server)" + 
			     Def.LBRACE);
    
    }
  
    protected void handleRegisterTable(MibNode aNode,String name,String id) 
	throws IOException {
	// regTable_impl.append(Def.TAB2 + "try " + Def.LBRACE );
        // regTable_impl.append(Def.TAB2 + "if (server != null)\n" + 
	//		     Def.TAB3 + "table" + name + " = new " + 
	//		     prefix + name + 
	//		     Def.TABLEMETA + "(mib, objectserver, server)" 
	//		     + Def.SEMICOLON);
        // regTable_impl.append(Def.TAB2 + "else\n");
	
	String metaName = 
	    MetaTableGenerator.buildMetaName(context, context.prefix, name);
	String metafactory = getMetaFactoryName(metaName);

	regTable_impl.append(Def.TAB2 + "table" + name + " = " + metafactory + 
			     "(\"" + name + "\", \"" + varName + 
			     "\", mib, server)" 
			     + Def.SEMICOLON);
	// regTable_impl.append(Def.TAB2 + Def.N_RBRACE +
	//		     " catch(" + Def.EXCP_SNMP + " e) " + Def.LBRACE +
	//		     Def.TAB3 + "table" + name + " = null" + 
	//		     Def.SEMICOLON + Def.TAB2 + Def.RBRACE);
        regTable_impl.append(Def.TAB2 + "if ( table" + name + " != null) " +
			     Def.LBRACE + Def.TAB3 + 
			     "table" + name + "." + Def.METH_T_REGENTRY +
			     "(mib,server)" + Def.SEMICOLON +
			     Def.TAB3 + "mib." + Def.METH_T_REGTABLEMETA + 
			     "(\"" + name + "\", table" + name + ")" + 
			     Def.SEMICOLON + Def.TAB2 + Def.RBRACE + "\n");
    }


    public void generateFactoryComments(String groupName, String className,
					String tableName, String type, 
					StringBuffer result) {
	result.append("\n" + Def.TAB + "/**");
	result.append("\n" + Def.TAB + " * " + 
		      MessageHandler.getMessage("generate.mib.comment.factory.table.abstract." + type, tableName));
	result.append("\n" + Def.TAB + " * ");
	result.append("\n" + Def.TAB + " * " + 
		      MessageHandler.getMessage("generate.mib.comment.factory.text1." + type));
	result.append("\n" + Def.TAB + " * " + 
		      MessageHandler.getMessage("generate.mib.comment.factory.text2." + type));
	result.append("\n" + Def.TAB + " * ");
	result.append("\n" + Def.TAB + " * " + 
		      MessageHandler.getMessage("generate.mib.comment.factory.table.param.tablename", tableName));
	result.append("\n" + Def.TAB + " * " + 
		      MessageHandler.getMessage("generate.mib.comment.factory.table.param.groupname", groupName));
	result.append("\n" + Def.TAB + " * " + 
		      MessageHandler.getMessage("generate.mib.comment.factory.table.param.mib"));
	result.append("\n" + Def.TAB + " * " + 
		      MessageHandler.getMessage("generate.mib.comment.factory.entry.param.server"));
	result.append("\n" + Def.TAB + " * ");
	result.append("\n" + Def.TAB + " * " + 
		      MessageHandler.getMessage("generate.mib.comment.factory.return1."+type));
	result.append("\n" + Def.TAB + " * " + 
		      MessageHandler.getMessage("generate.mib.comment.factory.table.return2."+type, tableName, className));
	result.append("\n" + Def.TAB + " * ");
	result.append("\n" + Def.TAB + " **/" + "\n");
    }

    protected void handleTableFactory(MibNode aNode,String name,String id) 
	throws IOException {
	generateMetaFactory(varName,name,factory_impl);
    }

    protected String getMetaFactoryName(String metaName) {
	return "create" + metaName + "Node";
    }

    protected void createMeta(String metaName, StringBuffer result) {
	result.append( Def.TAB2 +
		      Def.RETURN + "new " + metaName + 
		      "(mib, " + OBJSRV + ")" + 
		      Def.SEMICOLON);
    }

    protected void generateMetaFactory(String groupName, String tableName,
				       StringBuffer result) {
 	String metaName = 
	    MetaTableGenerator.buildMetaName(context, context.prefix, 
					     tableName);
	String metafactory = getMetaFactoryName(metaName);

	generateFactoryComments(groupName,metaName,tableName,"meta",result);

	result.append(Def.TAB + Def.PROTECTED + metaName + " " + 
		      metafactory + "(String tableName, String groupName, " + 
		      Def.SNMP_MIB + " mib, MBeanServer server) " 
		      + Def.LBRACE);
	createMeta(metaName,result);
	result.append(Def.TAB + Def.RBRACE + "\n");
    }

    protected void closeRegisterTable() throws IOException {
	regTable_impl.append(Def.TAB +  Def.RBRACE + "\n");
    }

    protected void handleDeclareTable(MibNode aNode,String name,String id) {
        var_def.append(Def.TAB + Def.PROTECTED + prefix + 
		       name + Def.TABLEMETA + " table" + name + " = null" 
		       + Def.SEMICOLON);
    }

    protected void handleTableId(MibNode aNode,String name,String id) 
	throws IOException {
	// to be implemented in subclasses...
	super.handleTableId(aNode,name,id);
	tablecount++;
	handleIsTable(aNode,name,id);
	handleGetTable(aNode,name,id);
	handleRegisterTable(aNode,name,id);
	handleDeclareTable(aNode,name,id);
	handleTableFactory(aNode,name,id);
    }

    protected void buildMethodHeaders() throws IOException {
	super.buildMethodHeaders();
	buildIsTableHeader();
	buildGetTableHeader();
	buildRegisterTableHeader();
    }

    protected  void closeMethods() throws IOException {
	super.closeMethods();
	closeIsTable();
	closeGetTable();
	closeRegisterTable();
    }

    protected  void writeMethods() throws IOException {
	super.writeMethods();
        write(isTable_impl.toString());
        write(getTable_impl.toString());
        write(regTable_impl.toString());
        write(factory_impl.toString());
    }

    protected StringBuffer isTable_impl;
    protected StringBuffer getTable_impl;
    protected StringBuffer getTable_body;
    protected StringBuffer regTable_impl;
    protected StringBuffer factory_impl;
    protected int tablecount;
}
